import 'dart:typed_data';

import 'package:cryptography/cryptography.dart';
import 'package:dartls/src/rtp/header.dart';
import 'package:dartls/src/rtp/rtp_packet.dart';
// package srtp

// import (
// 	"crypto/aes"
// 	"crypto/cipher"
// 	"encoding/binary"
// 	"errors"

// 	"github.com/adalkiran/webrtc-nuts-and-bolts/src/rtp"
// )

// https://github.com/pion/srtp/blob/e338637eb5c459e0e43daf9c88cf28dd441eeb7c/context.go#L9
// const (
const labelSRTPEncryption = 0x00;
const labelSRTPAuthenticationTag = 0x01;
const labelSRTPSalt = 0x02;

const labelSRTCPEncryption = 0x03;
const labelSRTCPAuthenticationTag = 0x04;
const labelSRTCPSalt = 0x05;

const seqNumMedian = 1 << 15;
const seqNumMax = 1 << 16;
// )

class Crypter {
  AesGcm algorthim;
  Uint8List key;

  Crypter(this.algorthim, this.key);
}

class GCM {
  Crypter srtpGCM;
  Uint8List srtpSalt;
  Crypter srtcpGCM;
  Uint8List srtcpSalt;

  GCM(this.srtpGCM, this.srtpSalt, this.srtcpGCM, this.srtcpSalt);

  static GCM newGCM(Uint8List masterKey, Uint8List masterSalt) {
    final srtpSessionKey = aesCmKeyDerivation(
        labelSRTPEncryption, masterKey, masterSalt, 0, masterKey.length);
    final srtpGCM = Crypter(AesGcm.with128bits(), srtpSessionKey);

    final srtcpSessionKey = aesCmKeyDerivation(
        labelSRTCPEncryption, masterKey, masterSalt, 0, masterKey.length);

    final srtcpGCM = Crypter(AesGcm.with128bits(), srtcpSessionKey);

    final srtpSalt = aesCmKeyDerivation(
        labelSRTPSalt, masterKey, masterSalt, 0, masterSalt.length);

    final srtcpSalt = aesCmKeyDerivation(
        labelSRTCPSalt, masterKey, masterSalt, 0, masterSalt.length);

    return GCM(srtpGCM, srtpSalt, srtcpGCM, srtcpSalt);
  }

  Uint8List rtpInitializationVector(RtpHeader header, int roc) {
    final iv = Uint8List(12);
    ByteData writer = ByteData.sublistView(iv);
    // binary.BigEndian.PutUint32(iv[2:], header.SSRC)
    writer.setUint32(2, header.ssrc);
    // binary.BigEndian.PutUint32(iv[6:], roc)
    writer.setUint32(6, roc);
    writer.setUint32(6, header.sequenceNumber);

    for (int i in iv) {
      iv[i] ^= srtpSalt[i];
    }
    return iv;
  }

  Future<Uint8List> decrypt(RtpPacket packet, int roc) async {
    final ciphertext = packet.rawData;

    Uint8List dst = ciphertext.sublist(0);
    final aeadAuthTagLen = 16;
    final resultLength = ciphertext.length - aeadAuthTagLen;
    if (resultLength < dst.length) {
      dst = dst.sublist(0, resultLength);
    }

    final iv = rtpInitializationVector(packet.header, roc);

    // func (cipher.AEAD) Open(dst []byte, nonce []byte, ciphertext []byte, additionalData []byte) ([]byte, error)

    // if _, err := g.srtpGCM.Open(
    // 	dst[packet.HeaderSize:packet.HeaderSize], iv, ciphertext[packet.HeaderSize:], ciphertext[:packet.HeaderSize],
    // );

    final secretBox = SecretBox(ciphertext.sublist(packet.headerSize),
        nonce: iv,
        mac: Mac(ciphertext.sublist(ciphertext.length - aeadAuthTagLen)));

    final decryptedBytes = await srtpGCM.algorthim.decrypt(secretBox,
        secretKey: SecretKey(srtpGCM.key),
        aad: ciphertext.sublist(0, packet.headerSize));

    // copy(dst[:packet.HeaderSize], ciphertext[:packet.HeaderSize])
    return Uint8List.fromList(decryptedBytes);
  }
}



// https://github.com/pion/srtp/blob/3c34651fa0c6de900bdc91062e7ccb5992409643/key_derivation.go#L8
Uint8List aesCmKeyDerivation(int label, Uint8List masterKey,
    Uint8List masterSalt, int indexOverKdr, int outLen)
// ([]byte, error)
{
  if (indexOverKdr != 0) {
    // 24-bit "index DIV kdr" must be xored to prf input.
    throw ("non-zero kdr not supported");
  }

  // https://tools.ietf.org/html/rfc3711#appendix-B.3
  // The input block for AES-CM is generated by exclusive-oring the master salt with the
  // concatenation of the encryption key label 0x00 with (index DIV kdr),
  // - index is 'rollover count' and DIV is 'divided by'

  final nMasterKey = masterKey.length;
  final nMasterSalt = masterSalt.length;

  // prfIn := make([]byte, nMasterKey)
  // copy(prfIn[:nMasterSalt], masterSalt)
  final prfIn = masterSalt.sublist(0, nMasterSalt);

  prfIn[7] ^= label;

  // The resulting value is then AES encrypted using the master key to get the cipher key.
  // block, err := aes.NewCipher(masterKey)
  final block = AesGcm.with128bits();
  // if err != nil {
  // 	return nil, err
  // }

  // out := make([]byte, ((outLen+nMasterKey)/nMasterKey)*nMasterKey)
  Uint8List out =
      Uint8List((((outLen + nMasterKey) / nMasterKey) * nMasterKey).toInt());
  int i = 0; // uint16

  ByteData writer = ByteData.sublistView(prfIn);
  for (int n = 0; n < outLen; n += nMasterKey) {
    // binary.BigEndian.PutUint16(prfIn[nMasterKey-2:], i)
    writer.setUint16(nMasterKey - 2, i);
    // block.Encrypt(out[n:n+nMasterKey], prfIn)
    block.encrypt(prfIn,
        secretKey: SecretKey(masterKey),
        possibleBuffer: Uint8List.view(out.buffer, n, n + nMasterKey));

    i++;
  }
  return out.sublist(0, outLen);
}
